# SCU-Pipelined-CPU
This project involves the design, implementation, and verification of a 32-bit, 5-stage pipelined CPU using Verilog, based on the SCU Instruction Set Architecture. 

## Authors
Andrew Vattuone, Nico Villegas-Kirchman, Trisha Ganesh

## Description

Modern processors rely on instruction pipelining to achieve high throughput, allowing multiple instructions to occupy execution stages simultaneously. A Verilog implementation of a 32-bit pipelined processor was designed to support the SCU Instruction Set Architecture (ISA), including 64 general purpose registers, five pipeline stages (IF, ID, EX, MEM, WB), and a word-addressed memory model.  The design included the construction of the datapath and control logic that provide support for 11 core  instructions: NOP, SVPC, LD, ST, ADD, INC, NEG, SUB, J, BRZ, and BRN, along with branch logic handling and to ensure correct execution. To evaluate correctness and performance, a benchmark program was developed to compute a one-dimensional median stencil over an array of 32-bit signed Integers. The final waveform simulation confirmed instruction flow, hazard resolution, and correctness of results. Together,  these components help us understand how a pipelined processor executes instructions efficiently and correctly.                                          

The 32-bit pipelined CPU was designed to support the SCU Instruction Set Architecture (ISA), featuring  64 general-purpose registers (x0–x63), a word-addressed memory model, and five pipeline stages: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). These five pipeline stages help increase instruction throughput by overlapping execution and by reducing the critical path for each stage. The CPU supports the execution of 11 core instructions: NOP, SVPC, LD, ST, ADD, INC, NEG, SUB, J, BRZ, and BRN, while handling branch logic and pipeline hazards to ensure proper execution. 

During the IF stage, instructions are fetched from memory using the Program Counter (PC), incrementing sequentially and updates based on the jump or branch instructions. Sequential fetching helps ensure a smooth instruction flow, well the branch updates allow correct program flow. The instruction is decoded during the ID stage and reads operands from the register file, extracting any immediate values. This ensures that decoding and operating fetching do not delay any arithmetic or memory operations. 

During the EX stage, the ALU performs both arithmetic and logical operations (addition, subtraction, negation) or directly passes values when they are required. The branch instructions are evaluated using zero (Z) and negative (N) flags from the previous ALU operation (from the later MEM stage), allowing efficient execution without needing additional instructions. Lastly, the MEM stage accesses the memory for load (LD) and store (ST) instructions and the WB stage writes the computed results back to the destination register, ensuring consistency. 

The datapath includes the register file, ALU, multiplexers for operand selection, PC-update core logic, and memory units. Control signals are generated based on the instruction opcodes for the ALU, memory access, branch decisions, and register writes. The truth table maps the opcodes to control outputs. This ensures the correct execution and handling of hazards, including the NOP insertion. NOP insertion was implemented to handle data hazards and prevent conflicts between instructions that depend on previous results. This maintains correctness without complex forwarding logic. For example, in the 1-D median stencil program, the LD instructions load consecutive array elements efficiently from memory. The ADD and SUB instructions compute differences to compute the median while the ST instructions store the results in the output array. Pipeline hazards are carefully managed with NOP insertion to prevent any conflict between memory and arithmetic operations. Furthermore, the waveform simulations confirm proper instruction flow, memory access, branch execution, and accuracy in results. Overall, the CPU design illustrates how choices in datapath, branch execution, and management of hazards allow the processor to execute instructions efficiently and correctly, while supporting all 11 SCU ISA instructions in a cohesive Verilog implementation. 


## Components

### #1: 1-D Median Stencil Assembly Program
The 1-D median stencil assembly program serves as a benchmark to evaluate the correctness and performance of the 32-bit pipelined CPU. It processes an input array of 32-bit signed integers and computes the median of each interior element based on its neighbors, storing the results in an output array. The conditions are handled explicitly for the first and last elements, and ensure correctness for all array sizes. The program demonstrates the ability to execute the full SCU ISA, including the arithmetic operations ADD and SUB, the memory operations LD and ST, and the branch instructions BRN and BRZ, while correctly handling pipeline hazards through NOP insertion. The program includes comments and labels to provide readability, making the program both functional and a thorough demonstration of the CPU’s instruction flow, correct data handling, and hazard resolution. Note that at the very end we also included a NEG instruction, although it doesn’t do anything for the 1-d stencil code itself.

### #2: Datapath and Control Design

### #3: Control Truth Table
SCU ISA Truth Table:

### #4: Performance Analysis
The instruction count of our program is dependent on the problem size n as well as the specific values of the inputted array a (note that for the instruction count we are including the NOP at the end of the original program and the NEG demonstration instruction at the end of the new program). Initially, since our BRZ, BRN, and J instructions all determined whether to jump or not in the EX stage, we decided to include two NOPs after each of these branching instructions. This was similar to what we found, where 3 NOPs needed to be added after each branch instruction to prevent branching hazards (in our case, since it occurred in the EX stage, we needed only 2 NOPS). However, while we were testing our code, we noticed that the BRZ, BRN, and J instructions were skipping over the second NOP instruction whenever a branch was taken, but the second NOP was not skipped when the branch wasn’t taken. Upon further review, we realized that because our buffers update on the negedge of the clock while our functional units update on the posedge, this means that when BRZ, BRN, and J calculate their values in the EX stage, they are guaranteed to be immediately placed into the IF stage and overwrite any incoming instructions. This means that only the instructions in the ID stage are lost rather than in both the IF and ID stages, so technically only one NOP would be needed rather than two. Therefore, the total number of instructions executed slightly depends on how many branch instructions result in a branch taken or not, as it will determine if the second NOP will be executed or skipped over. Functionally everything is correct, and the only difference is that it makes the CPI slightly more difficult to count without knowing the exact input beforehand. So when the number of instructions executed are counted later in this section, just note that the second NOP after a branch instruction will be skipped only if the branch is taken, which means it doesn’t count toward total instruction execution count.

Aside from the number of NOPs that are executed, the number of instructions executed inside the for loop is dependent on the exact values of a[i-1], a[i], a[i+1]. While the first 20 instructions for setting up the values and the last 7 to determine if another loop iteration should be performed always execute for each iteration of the loop, the number of instructions executed within the if-else block is not always the same. For example, suppose a[i-1] = 3, a[i] = 1, and a[i+1] = 5. Based on tracing out the if-else block manually for this example, 4 instructions execute for the if a[i-1] >= a[i] comparison (branch not taken since true), 3 instructions during the if a[i] >= a[i+1] comparison (branch taken since false, so skip second NOP), 3 instructions during the else if a[i-1] >= a[i+1] comparison (branch taken since false, so skip second NOP), and 3 instructions to set b[i] = a[i-1] = 3 (skip second NOP since branch always taken for J), for a total of 4 + 3 + 3 + 3 = 13 instructions. However, let’s look a different example where a[i-1] = 5, a[i] = 7, and a[i+1] = 2. Tracing this out manually yields 3 executed instructions for the if a[i-1] >= a[i] comparison (branch taken since false, so skip second NOP), 4 instructions for the if a[i-1] >= a[i+1] comparison (branch not taken since true, so include second NOP), and 3 instructions to set b[i] = a[i-1] = 5 (skip second NOP since branch always taken for J), for a total of 3 + 4 + 3 = 10 instructions executed. Thus, the number of instructions executed per loop is not always a fixed value and depends on the exact values of a[i-1], a[i], and a[i+1], making exact CPI calculation for n inputs more difficult.

Finally, the number of instructions executed is not entirely dependent on the number of loop iterations, as if n = 0, n = 1, or n = 2, a smaller but fixed number of instructions will run for these cases, regardless of the exact value of the inputs of the array a. In the case of n = 0, 1 instruction will run to set x0 = 0, 9 instructions to set the SVPC values, 3 instructions to check if n == 0 (note the second NOP is skipped since the branch is taken), 1 instruction for the NOP at the end of the 1-d median stencil portion of the program that represents the end of the program, and 1 instruction for the NEG demo instruction at the new end of the program, for a total of 1 + 9 + 3 + 1 + 1 = 15 instructions. In the case of n = 1, the first 10 instructions will run just like in the n = 0 case, 4 instructions will execute to check if n <= 0 (the second NOP is NOT skipped in this case since the branch is NOT taken), 5 instructions to set b[0] = a[0], 1 instruction to set i = 0, 3 instructions to check if n == 1 (not the second NOP is skipped since the branch is taken), and the same 2 NOP and NEG instructions at the end of the program as when n = 0, for a total of 10 + 4 + 5 + 1 + 3 + 2 = 25 instructions. Finally, when n = 2, the first 20 instructions will run just as they did for the case n = 1, then 4 instructions to check if n == 1 (the second NOP is NOT skipped in this case since the branch is NOT taken), 3 instructions to check if n == 2 (the second NOP is skipped in this case since the branch is taken), 13 instructions to set b[n] = a[n], and the 2 instructions at the end (NOP and NEG), for a total of 20 + 4 + 3 + 13 + 2 = 42 instructions. Only in the cases when n = 0, n = 1, and n = 2 will the exact number of instructions always be known regardless of the values of the array a.

For any cases where n > 2, the first 28 instructions of the program will always execute (since the n == 2 comparison is false, the branch isn’t taken, so the NOP is included in this case), while the final 15 instructions will also always execute, for a total of 28 + 15 = 43 instructions. However, the number of loop instructions depends not only on n, but also on the exact values of the array a (as mentioned earlier in the if-else loop block section). Therefore, to calculate the CPI, we will calculate the maximum number of instructions that could execute in the loop and the minimum number of instructions that could execute in the loop, which will form a range for the possible number of instructions that could execute for a given array of length n > 2. It’s always the case that the first 20 and last 7 instructions run within the loop (except for the very last iteration, which will run 8 times), so 27 instructions will run regardless of the exact values of a. For a single if-else block, the maximum number of instructions that could execute is 4 + 3 + 3 + 3 = 13, while the minimum number of instructions that could execute is 3 + 4 + 3 = 10. Therefore, the maximum number of instructions run per iteration will be (n - 3)*(27 + 13) + (28 + 13) = 40n - 79, while the minimum number of instructions run per iteration will be (n - 3)*(27 + 10) + (28 + 10) = 37n - 73. So the total number of instructions that will run for cases when n > 2 will be between 43 + 37n - 73 = 37n - 30 instructions and 43 + 40n - 79 = 40n - 36 instructions. 
The table below summarizes all the different possible instruction counts based on the input size n:

| Value of Input Size n  |                      Instruction Count                            |
|     :---:              |                            :---:                                  |
|       n &lt;= 0        |                       15 Instructions                             |
|        n = 1           |                       25 Instructions                             |
|        n = 2           |                       42 Instructions                             |
|        n > 2           | 37n - 30 Instructions  Total Instructions  40n - 36 Instructions  |



Counting the total number of instructions yields 15, 25, and 42 for n = 0, n = 1, and n = 2, respectively. To verify this is true, we can use a waveform to determine the time each program finishes reading the final instruction and then use the clock cycle of 10ns to determine the total number of instructions read and thus verify if our values are correct or not. We will do this in the next section after describing the CPI equations. 

Because this datapath is pipelined, all instructions will take only 1 cycle to complete, except for the very last instruction (the NEG instruction), which will take 5 cycles to complete. Therefore, to calculate the total number of cycles it takes for a particular program to complete based on input size n, just add 4 (5 cycles for NEG - 1 cycle for original NEG = 4 cycles). To calculate the CPI, all we need to do is take the total number of cycles and divide it by the total number of instructions executed in the program. The table below shows this for all possible values of the input size n:

| Value of Input Size n  |                      CPI                                                                                                                |
|     :---:              |                            :---:                                                                                                        |
|       n &lt;= 0        |                       (15 + 4 cycles) / 15 instructions = 19 cycles / 15 instructions = 1.266667 CPI                                        |
|        n = 1           |                       (25 + 4 cycles) / 25 instructions = 29 cycles / 25 instructions = 1.16 CPI                                            |
|        n = 2           |                       (42 + 4 cycles) / 42 instructions = 46 cycles / 42 instructions = 1.095238 CPI                                        |
|        n > 2           |Max CPI = (40n - 36 + 4 cycles) / (40n - 36 instructions) = (40n - 32 cycles) / (40n - 36 instructions) = (40n - 32) / (40n - 36) CPI <br /> Min CPI = (37n - 30 + 4 cycles) / (37n - 30 instructions) = (37n - 26 cycles) / (37n - 30 instructions) = (37n - 26) / (37n - 30) CPI <br /> Therefore: (37n - 26) / (37n - 30) CPI <= Actual CPI <= (40n - 32) / (40n - 36) CPI                                                      |

To test if these CPIs are correct, we can use waveforms just like we proposed for the instruction counts. We will verify the correctness of both the instruction counts and the CPIs with waveforms below. In all cases, the start time is at 0ns and the clock rate is 10ns, as it flips its value every 5ns. The waveform below proves both of these facts. We will use these values for all 4 cases (n = 0, n = 1, n = 2, n > 2), and the input array a will be the same default array of [3,1,5,7,2,9,8] starting at address 2 while b will start at address 71.


                                  





