# SCU-Pipelined-CPU
This project involves the design, implementation, and verification of a 32-bit, 5-stage pipelined CPU using Verilog, based on the SCU Instruction Set Architecture. 

## Authors
Andrew Vattuone, Nico Villegas-Kirchman, Trisha Ganesh

## Description

Modern processors rely on instruction pipelining to achieve high throughput, allowing multiple instructions to occupy execution stages simultaneously. A Verilog implementation of a 32-bit pipelined processor was designed to support the SCU Instruction Set Architecture (ISA), including 64 general purpose registers, five pipeline stages (IF, ID, EX, MEM, WB), and a word-addressed memory model.  The design included the construction of the datapath and control logic that provide support for 11 core  instructions: NOP, SVPC, LD, ST, ADD, INC, NEG, SUB, J, BRZ, and BRN, along with branch logic handling and to ensure correct execution. To evaluate correctness and performance, a benchmark program was developed to compute a one-dimensional median stencil over an array of 32-bit signed Integers. The final waveform simulation confirmed instruction flow, hazard resolution, and correctness of results. Together,  these components help us understand how a pipelined processor executes instructions efficiently and correctly.                                          

The 32-bit pipelined CPU was designed to support the SCU Instruction Set Architecture (ISA), featuring  64 general-purpose registers (x0–x63), a word-addressed memory model, and five pipeline stages: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). These five pipeline stages help increase instruction throughput by overlapping execution and by reducing the critical path for each stage. The CPU supports the execution of 11 core instructions: NOP, SVPC, LD, ST, ADD, INC, NEG, SUB, J, BRZ, and BRN, while handling branch logic and pipeline hazards to ensure proper execution. 

During the IF stage, instructions are fetched from memory using the Program Counter (PC), incrementing sequentially and updates based on the jump or branch instructions. Sequential fetching helps ensure a smooth instruction flow, well the branch updates allow correct program flow. The instruction is decoded during the ID stage and reads operands from the register file, extracting any immediate values. This ensures that decoding and operating fetching do not delay any arithmetic or memory operations. 

During the EX stage, the ALU performs both arithmetic and logical operations (addition, subtraction, negation) or directly passes values when they are required. The branch instructions are evaluated using zero (Z) and negative (N) flags from the previous ALU operation (from the later MEM stage), allowing efficient execution without needing additional instructions. Lastly, the MEM stage accesses the memory for load (LD) and store (ST) instructions and the WB stage writes the computed results back to the destination register, ensuring consistency. 

The datapath includes the register file, ALU, multiplexers for operand selection, PC-update core logic, and memory units. Control signals are generated based on the instruction opcodes for the ALU, memory access, branch decisions, and register writes. The truth table maps the opcodes to control outputs. This ensures the correct execution and handling of hazards, including the NOP insertion. NOP insertion was implemented to handle data hazards and prevent conflicts between instructions that depend on previous results. This maintains correctness without complex forwarding logic. For example, in the 1-D median stencil program, the LD instructions load consecutive array elements efficiently from memory. The ADD and SUB instructions compute differences to compute the median while the ST instructions store the results in the output array. Pipeline hazards are carefully managed with NOP insertion to prevent any conflict between memory and arithmetic operations. Furthermore, the waveform simulations confirm proper instruction flow, memory access, branch execution, and accuracy in results. Overall, the CPU design illustrates how choices in datapath, branch execution, and management of hazards allow the processor to execute instructions efficiently and correctly, while supporting all 11 SCU ISA instructions in a cohesive Verilog implementation. 


## Components

### #1: 1-D Median Stencil Assembly Program
The 1-D median stencil assembly program serves as a benchmark to evaluate the correctness and performance of the 32-bit pipelined CPU. It processes an input array of 32-bit signed integers and computes the median of each interior element based on its neighbors, storing the results in an output array. The conditions are handled explicitly for the first and last elements, and ensure correctness for all array sizes. The program demonstrates the ability to execute the full SCU ISA, including the arithmetic operations ADD and SUB, the memory operations LD and ST, and the branch instructions BRN and BRZ, while correctly handling pipeline hazards through NOP insertion. The program includes comments and labels to provide readability, making the program both functional and a thorough demonstration of the CPU’s instruction flow, correct data handling, and hazard resolution. Note that at the very end we also included a NEG instruction, although it doesn’t do anything for the 1-d stencil code itself.

### #2: Datapath and Control Design

### #3: Control Truth Table
SCU ISA Truth Table:

### #4: Performance Analysis
The instruction count of our program is dependent on the problem size n as well as the specific values of the inputted array a (note that for the instruction count we are including the NOP at the end of the original program and the NEG demonstration instruction at the end of the new program). Initially, since our BRZ, BRN, and J instructions all determined whether to jump or not in the EX stage, we decided to include two NOPs after each of these branching instructions. This was similar to what we found, where 3 NOPs needed to be added after each branch instruction to prevent branching hazards (in our case, since it occurred in the EX stage, we needed only 2 NOPS). However, while we were testing our code, we noticed that the BRZ, BRN, and J instructions were skipping over the second NOP instruction whenever a branch was taken, but the second NOP was not skipped when the branch wasn’t taken. Upon further review, we realized that because our buffers update on the negedge of the clock while our functional units update on the posedge, this means that when BRZ, BRN, and J calculate their values in the EX stage, they are guaranteed to be immediately placed into the IF stage and overwrite any incoming instructions. This means that only the instructions in the ID stage are lost rather than in both the IF and ID stages, so technically only one NOP would be needed rather than two. Therefore, the total number of instructions executed slightly depends on how many branch instructions result in a branch taken or not, as it will determine if the second NOP will be executed or skipped over. Functionally everything is correct, and the only difference is that it makes the CPI slightly more difficult to count without knowing the exact input beforehand. So when the number of instructions executed are counted later in this section, just note that the second NOP after a branch instruction will be skipped only if the branch is taken, which means it doesn’t count toward total instruction execution count.

Aside from the number of NOPs that are executed, the number of instructions executed inside the for loop is dependent on the exact values of a[i-1], a[i], a[i+1]. While the first 20 instructions for setting up the values and the last 7 to determine if another loop iteration should be performed always execute for each iteration of the loop, the number of instructions executed within the if-else block is not always the same. For example, suppose a[i-1] = 3, a[i] = 1, and a[i+1] = 5. Based on tracing out the if-else block manually for this example, 4 instructions execute for the if a[i-1] >= a[i] comparison (branch not taken since true), 3 instructions during the if a[i] >= a[i+1] comparison (branch taken since false, so skip second NOP), 3 instructions during the else if a[i-1] >= a[i+1] comparison (branch taken since false, so skip second NOP), and 3 instructions to set b[i] = a[i-1] = 3 (skip second NOP since branch always taken for J), for a total of 4 + 3 + 3 + 3 = 13 instructions. However, let’s look a different example where a[i-1] = 5, a[i] = 7, and a[i+1] = 2. Tracing this out manually yields 3 executed instructions for the if a[i-1] >= a[i] comparison (branch taken since false, so skip second NOP), 4 instructions for the if a[i-1] >= a[i+1] comparison (branch not taken since true, so include second NOP), and 3 instructions to set b[i] = a[i-1] = 5 (skip second NOP since branch always taken for J), for a total of 3 + 4 + 3 = 10 instructions executed. Thus, the number of instructions executed per loop is not always a fixed value and depends on the exact values of a[i-1], a[i], and a[i+1], making exact CPI calculation for n inputs more difficult.



